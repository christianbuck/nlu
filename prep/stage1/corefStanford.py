# LKG

import nltk
from commonUtil import cUtil


class corefStan(object):
    '''
    classdocs
    '''


    def __init__(self):
        '''
        Constructor
        '''


    # Extract a list of sentence-internal coreference chains from the .JSON files generated by the Stanford coreNLP tool
    def getCorefChains(self, corefDict, docID, sentsDict):
        #print "corefDict, docID, sentsDict", corefDict, docID, sentsDict
        common = cUtil()
        dictSentCoref = {} # {docID: {sentNo: [(start_word_index,end_word_index,type,identifier,string,used_up),...]}}


        lCorefChains = []
        lCorefChainTemp = []

        for sentenceNr, sentenceCoref in enumerate(corefDict):
            for lCorefChain in sentenceCoref:
                lCorefChainTemp = []
                for lCorefPair in lCorefChain:
                    refExpr = lCorefPair[0]
                    antecedent = lCorefPair[1]
                    refExpr[1] = sentenceNr  # fix because they are always 0 as we process sentences individually
                    antecedent[1] = sentenceNr

                    if not antecedent in lCorefChainTemp:
                        lCorefChainTemp.append(antecedent)
                    if not refExpr[0] in antecedent[0]: # Exclude referring expressions if they are contained within the antecedent OR overlap
                        lCorefChainTemp.append(refExpr)
                lCorefChains.append(lCorefChainTemp)

        identifier = 0 # The ID of the chain

        if not dictSentCoref.has_key(docID):
            dictSentCoref[docID] = {}  # {docID: {sentNo: [(start_word_index,end_word_index,identifier,string,used_up),...]}}

        for listChain in lCorefChains:
            for coref in listChain:
                sentNo = int(coref[1]) + 1

                start_word_index = coref[3]
                corefStringWords = coref[0].split(' ')
                if corefStringWords[0].lower() in ['the']:
                    corefStringWords.pop(0)
                    start_word_index += 1
                string = ' '.join(corefStringWords)

                # nschneid: modified; was:
                '''
                string = coref[0]
                corefStringWords = string.split(' ')
                deduct = 0
                string = ''
                for word in corefStringWords:
                    if word.lower() not in ['the']:
                        string += word + ' '
                    else:
                        deduct += 1
                string = string.rstrip(' ')
                start_word_index = coref[3] + deduct
                '''

                end_word_index = coref[4]
                adjusted = common.adjustIndices(sentsDict[docID][sentNo][1], sentsDict[docID][sentNo][0], start_word_index, end_word_index)
                start_word_index = adjusted[0]
                end_word_index = adjusted[1]
                if not dictSentCoref[docID].has_key(sentNo):
                    dictSentCoref[docID][sentNo] = [(start_word_index,end_word_index,identifier,string,False)]
                else:
                    dictSentCoref[docID][sentNo].append((start_word_index,end_word_index,identifier,string,False))

            identifier += 1

        dictSentCoref = self.formatChains(dictSentCoref)
        return dictSentCoref


    # Apply additional formatting to the coreference chains - sort the list elements and ensure only sentence-internal chain information is captured
    def formatChains(self,dictInput):
        # Sort the list of tuples for each sentence in the dictionary so that they are ordered by start_word_index
        for docID in dictInput:
            for sentNo in dictInput[docID]:
                tempList = dictInput[docID][sentNo]
                tempList.sort()
                fDist = {}
                listCorefMult = []
                listCorefChains = []
                listFinal = []
                # Now swap any items so that if there are two elements with the same start_word_index, the one with the larger span appears first
                if len(tempList) > 1:
                    for i in range(0,len(tempList)-1):
                        if tempList[i][0] == tempList[i+1][0] and tempList[i][1] < tempList[i+1][1]:
                            tempList[i+1], tempList[i] = tempList[i], tempList[i+1]
                        # As we are only interested in sentence internal coreference, compile a list of corefChainIDs in the sentence
                        listCorefChains.append(int(tempList[i][2]))
                    # Add corefChainID for the last entry in the list
                    listCorefChains.append(int(tempList[i+1][2]))
                    fDist = nltk.FreqDist(listCorefChains) # Find how many times each corefChainID appears in the sentence
                    for e in fDist:
                        if fDist[e] > 1:
                            listCorefMult.append(e)
                # Construct list of sentence internal coreference instances and write back to dictionary
                for element in tempList:
                    if int(element[2]) in listCorefMult:
                        listFinal.append(element)
                dictInput[docID][sentNo] = listFinal
        return dictInput
